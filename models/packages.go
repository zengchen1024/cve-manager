package models

import (
	"github.com/astaxie/beego/logs"
	"github.com/astaxie/beego/orm"

	"github.com/opensourceways/cve-manager/util"
)

func GetIpWhite(ip string, iw *IpWhite) (err error) {
	o := orm.NewOrm()
	err = o.Raw("select * FROM cve_ip_white WHERE machine_ip=?", ip).QueryRow(iw)
	if err == nil {
		logs.Info("GetIpWhite, ip:", ip, " ,In the whitelist")
	} else {
		// Do not process blacklist
		//logs.Error("ip:", ip, " Restricted access")
	}
	return nil
}

func GetPackageInfo(packageName, version string, gi *GitPackageInfo) (err error) {
	o := orm.NewOrm()
	err = o.Raw("select * FROM cve_git_package_info WHERE package_name=? and version=? and status=?",
		packageName, version, 0).QueryRow(gi)
	if err == nil {
		logs.Info("GetPackageInfo, cve_git_package_info, "+
			"packageName: ", packageName, ", search successful")
		return nil
	} else {
		logs.Error("GetPackageInfo, cve_git_package_info, "+
			"packageName: ", packageName, ", Data does not exist, err: ", err)
	}
	return err
}

func GetSubPackage(packageInfoId int64) (gg []GitSubPack, num int64, err error) {
	o := orm.NewOrm()
	var gs []GitSubPack
	num, err = o.Raw("select sub_id,ids,sub_pack_name "+
		"FROM cve_git_sub_pack WHERE detail_id=?",
		packageInfoId).QueryRows(&gs)
	if num > 0 && err == nil {
		logs.Info("GetSubPackage, cve_git_sub_pack, "+
			"packageInfoId: ", packageInfoId, " , search successful")
		return gs, num, nil
	} else {
		logs.Error("GetSubPackage, cve_git_sub_pack, "+
			"packageInfoId: ", packageInfoId, " , Data does not exist, err: ", err)
	}
	return gs, 0, err
}

func GetSubPackProvide(subId int64) (gg []GitSubPackProvides, num int64, err error) {
	o := orm.NewOrm()
	var gs []GitSubPackProvides
	num, err = o.Raw("select provide_id,ids,provide_name, requiredb "+
		"FROM cve_git_sub_pack_provides WHERE sub_id=?",
		subId).QueryRows(&gs)
	if num > 0 && err == nil {
		logs.Info("GetSubPackProvide, cve_git_sub_pack_provides, "+
			"subId: ", subId, " , search successful")
		return gs, num, nil
	} else {
		logs.Error("GetSubPackProvide, cve_git_sub_pack_provides, "+
			"subId: ", subId, " , Data does not exist, err: ", err)
	}
	return gs, 0, err
}

func GetSubPackrequiredby(provideId int64) (gg []GitSubPackRequiredby, num int64, err error) {
	o := orm.NewOrm()
	var gs []GitSubPackRequiredby
	num, err = o.Raw("select id,requiredb FROM cve_git_sub_pack_requiredby WHERE provide_id=?",
		provideId).QueryRows(&gs)
	if num > 0 && err == nil {
		logs.Info("GetSubPackrequiredby, cve_git_sub_pack_requiredby, "+
			"provideId: ", provideId, " , search successful")
		return gs, num, nil
	} else {
		logs.Error("GetSubPackrequiredby, cve_git_sub_pack_requiredby, "+
			"provideId: ", provideId, " , Data does not exist, err: ", err)
	}
	return gs, 0, err
}

func GetSubPackRequire(subId int64) (gg []GitSubPackRequire, num int64, err error) {
	o := orm.NewOrm()
	var gs []GitSubPackRequire
	num, err = o.Raw("select require_id,ids,require_name, providedb "+
		"FROM cve_git_sub_pack_require WHERE sub_id=?",
		subId).QueryRows(&gs)
	if num > 0 && err == nil {
		logs.Info("GetSubPackRequire, cve_git_sub_pack_require, "+
			"subId: ", subId, " , search successful")
		return gs, num, nil
	} else {
		logs.Error("GetSubPackRequire, cve_git_sub_pack_require, "+
			"subId: ", subId, " , Data does not exist, err: ", err)
	}
	return gs, 0, err
}

func GetPackageList(pagesize int64, pagenum int64, QueryPkgName string) (ge []GitOpenEuler, num int64, err error) {
	o := orm.NewOrm()
	qs := o.QueryTable("cve_git_open_euler")
	offset := (pagenum - 1) * pagesize
	if QueryPkgName != "" {
		num, err = qs.Filter("package_name__icontains", QueryPkgName).Filter("status", 1).Limit(pagesize, offset).All(&ge)
	} else {
		num, err = qs.Filter("status", 1).Limit(pagesize, offset).All(&ge)
	}

	if err != nil {
		logs.Error("GetPackageList, cve_git_open_euler, err: ", err, ",pagesize ",
			pagesize, ",pagenum ", pagenum, ", QueryPkgName ", QueryPkgName)
	}

	return
}

func GetPackageNum(QueryPkgName string) (num int64) {
	o := orm.NewOrm()
	cg := o.QueryTable("cve_git_open_euler")
	var err error
	if QueryPkgName != "" {
		num, err = cg.Filter("package_name__icontains", QueryPkgName).Filter("status", 1).Count()
	} else {
		num, err = cg.Filter("git_id__gt", 0).Filter("status", 1).Count()
	}

	if err != nil {
		num = 0
	}

	return
}

func GetOtherPackageNum(pkgName string, id int64) int64 {
	o := orm.NewOrm()
	var table string
	switch id {
	case util.OpenGauss:
		table = "cve_open_guss_yaml"
	case util.MindSpore:
		table = "cve_mind_spore_yaml"
	case util.OpenLookeng:
		table = "cve_open_lookeng_yaml"
	default:
		return 0
	}

	cg := o.QueryTable(table)
	var num int64
	var err error
	if pkgName != "" {
		num, err = cg.Filter("package_name__icontains", pkgName).Filter("status", 1).Count()
	} else {
		num, err = cg.Filter("id__gt", 0).Filter("status", 1).Count()
	}

	if err == nil {
		return num
	}

	return 0
}

func GetPackageListForGauss(pagesize int64, pagenum int64, QueryPkgName string) (ge []OpenGussYaml, num int64, err error) {
	o := orm.NewOrm()
	qs := o.QueryTable("cve_open_guss_yaml")

	offset := (pagenum - 1) * pagesize
	if QueryPkgName != "" {
		num, err = qs.Filter("package_name__icontains", QueryPkgName).Filter("status", 1).Limit(pagesize, offset).All(&ge)
	} else {
		num, err = qs.Filter("status", 1).Limit(pagesize, offset).All(&ge)
	}

	if err != nil {
		logs.Error("GetPackageList, cve_open_guss_yaml, err: ", err, ",pagesize ",
			pagesize, ",pagenum ", pagenum, ", QueryPkgName ", QueryPkgName)
	}

	return
}

func GetPackageListForMindSpore(pagesize int64, pagenum int64, QueryPkgName string) (ge []MindSporeYaml, num int64, err error) {
	o := orm.NewOrm()
	qs := o.QueryTable("cve_mind_spore_yaml")
	if QueryPkgName != "" {
		num, err = qs.Filter("package_name__icontains", QueryPkgName).Filter("status", 1).Limit(pagesize, (pagenum-1)*pagesize).All(&ge)
	} else {
		num, err = qs.Filter("status", 1).Limit(pagesize, (pagenum-1)*pagesize).All(&ge)
	}

	if err != nil {
		logs.Error("GetPackageListForMindSpore, cve_mind_spore_yaml, err: ", err, ",pagesize ",
			pagesize, ",pagenum ", pagenum, ", QueryPkgName ", QueryPkgName)
	}

	return
}

func GetPackageListForOpenLook(pagesize int64, pagenum int64, QueryPkgName string) (ge []OpenLookengYaml, num int64, err error) {
	o := orm.NewOrm()
	qs := o.QueryTable("cve_open_lookeng_yaml")
	offset := (pagenum - 1) * pagesize

	if QueryPkgName != "" {
		num, err = qs.Filter("package_name__icontains", QueryPkgName).Filter("status", 1).Limit(pagesize, offset).All(&ge)
	} else {
		num, err = qs.Filter("status", 1).Limit(pagesize, offset).All(&ge)
	}

	if err != nil {
		logs.Error("GetPackageList, cve_open_lookeng_yaml, err: ", err, ",pagesize ",
			pagesize, ",pagenum ", pagenum, ", QueryPkgName ", QueryPkgName)
	}

	return
}
